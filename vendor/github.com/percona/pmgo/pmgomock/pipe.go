// Automatically generated by MockGen. DO NOT EDIT!
// Source: /home/karl/golang/src/github.com/percona/pmgo/pipe.go

package pmgomock

import (
	gomock "github.com/golang/mock/gomock"
	. "github.com/percona/pmgo"
	mgo_v2 "gopkg.in/mgo.v2"
)

// Mock of PipeManager interface
type MockPipeManager struct {
	ctrl     *gomock.Controller
	recorder *_MockPipeManagerRecorder
}

// Recorder for MockPipeManager (not exported)
type _MockPipeManagerRecorder struct {
	mock *MockPipeManager
}

func NewMockPipeManager(ctrl *gomock.Controller) *MockPipeManager {
	mock := &MockPipeManager{ctrl: ctrl}
	mock.recorder = &_MockPipeManagerRecorder{mock}
	return mock
}

func (_m *MockPipeManager) EXPECT() *_MockPipeManagerRecorder {
	return _m.recorder
}

func (_m *MockPipeManager) All(result interface{}) error {
	ret := _m.ctrl.Call(_m, "All", result)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockPipeManagerRecorder) All(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "All", arg0)
}

func (_m *MockPipeManager) AllowDiskUse() PipeManager {
	ret := _m.ctrl.Call(_m, "AllowDiskUse")
	ret0, _ := ret[0].(PipeManager)
	return ret0
}

func (_mr *_MockPipeManagerRecorder) AllowDiskUse() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "AllowDiskUse")
}

func (_m *MockPipeManager) Batch(n int) PipeManager {
	ret := _m.ctrl.Call(_m, "Batch", n)
	ret0, _ := ret[0].(PipeManager)
	return ret0
}

func (_mr *_MockPipeManagerRecorder) Batch(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Batch", arg0)
}

func (_m *MockPipeManager) Explain(result interface{}) error {
	ret := _m.ctrl.Call(_m, "Explain", result)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockPipeManagerRecorder) Explain(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Explain", arg0)
}

func (_m *MockPipeManager) Iter() *mgo_v2.Iter {
	ret := _m.ctrl.Call(_m, "Iter")
	ret0, _ := ret[0].(*mgo_v2.Iter)
	return ret0
}

func (_mr *_MockPipeManagerRecorder) Iter() *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "Iter")
}

func (_m *MockPipeManager) One(result interface{}) error {
	ret := _m.ctrl.Call(_m, "One", result)
	ret0, _ := ret[0].(error)
	return ret0
}

func (_mr *_MockPipeManagerRecorder) One(arg0 interface{}) *gomock.Call {
	return _mr.mock.ctrl.RecordCall(_mr.mock, "One", arg0)
}
