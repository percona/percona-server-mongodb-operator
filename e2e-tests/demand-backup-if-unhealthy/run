#!/bin/bash

set -o errexit

test_dir=$(realpath $(dirname $0))
. ${test_dir}/../functions
set_debug

create_secrets() {
  echo 'Creating secrets and start client'
  kubectl_bin apply -f "$test_dir/conf/secrets.yml" -f "$conf_dir/client.yml"
}

until_with_timeout() {
  local timeout="$1"
  shift

  local elapsed=0
  until "$@"; do
    if (( elapsed >= timeout )); then
      echo "Timeout after ${timeout}s: command '$*' did not succeed"
      exit 1
    fi
    sleep 1 && elapsed=$((elapsed + interval))
  done

  return 0
}

check_user() {
  run_mongo 'db.getUser("myApp")' \
    "userAdmin:userAdmin123456@$cluster-rs0.$namespace" \
    | grep -q '"user" : "myApp"'
}

write_data() {
	local data=$1
	local find_prefix=${2-""}

	run_mongo \
		"use myApp\n db.test.insert({ x: \"${data}\" })" \
		"myApp:myPass@${cluster}-rs0.${namespace}"
	compare_mongo_cmd "find" "myApp:myPass@${cluster}-rs0.${namespace}" "${find_prefix}" ".svc.cluster.local" "myApp" "test"
}

delete_data() {
  local data="$1"

  run_mongo \
    "use myApp\n db.test.deleteOne({ x: \"$data\" })" \
    "myApp:myPass@$cluster-rs0.$namespace"
}

update_with_invalid_db_image() {
  local cluster_name="${1:-some-name}"

  yq "$test_dir/conf/$cluster_name.yml" \
		| yq ".spec.image=\"invalid-image:invalid-tag\"" \
    | kubectl_bin apply -f -
}

rollback_invalid_image() {
  local cluster_name="${1:-some-name}"
  local timeout=

  apply_cluster "$test_dir/conf/$cluster_name.yml"
  echo -n "Waiting new statefulset version..."
  until ! kubectl_bin get statefulset "$cluster_name-rs0" \
    -o jsonpath='{range .spec.template.spec.containers[*]}{.image}{"\n"}{end}' \
    | grep -q "invalid-image:invalid-tag"; do
    echo -n .
    sleep 1
  done
  
  echo
  echo "Deleting crashing pod $cluster_name-rs0-2"
  kubectl_bin delete pod "$cluster_name-rs0-2"
}

is_sts_ready() {
  local sts_name="${1:-some-name-rs0}"
  local replicas ready_replicas

  until kubectl_bin get sts "$sts_name" &>/dev/null; do
    sleep 2
  done

  replicas=$(kubectl_bin get sts "$sts_name" -o jsonpath='{.spec.replicas}')
  ready_replicas=$(kubectl_bin get sts "$sts_name" -o jsonpath='{.status.readyReplicas}')

  [[ "$replicas" -eq "$ready_replicas" ]]
}

verify_sts_not_ready() {
  local sts_name="${1:-some-name-rs0}"

  if is_sts_ready "$sts_name"; then
    echo "StatefulSet $sts_name is ready during the backup, failing..."
    exit 1
  fi
}

wait_sts_to_become_not_ready() {
  local sts_name="${1:-some-name-rs0}"
  local timeout="${2:-60}"
  local pod_name="${sts_name}-1"
  local interval=2
  local elapsed=0

  echo "Updating cluster with invalid image..."
  update_with_invalid_db_image

  echo -n "Wait for statefulset $sts_name to become not ready..."
  until ! is_sts_ready "$sts_name"; do
    if (( elapsed >= timeout )); then
      echo "Timeout reached: statefulSet $sts_name still has ready replicas"
      exit 1
    fi
    sleep $interval && (( elapsed += interval ))
    echo -n .
  done
}

create_infra $namespace
deploy_minio
create_secrets
apply_s3_storage_secrets

cluster="some-name"
desc "create PSMDB cluster $cluster"
apply_cluster "$test_dir/conf/$cluster.yml"
wait_for_cluster_state "$cluster" "ready"

desc "Adding new user"
run_mongo \
	'db.createUser({user:"myApp",pwd:"myPass",roles:[{db:"myApp",role:"readWrite"}]})' \
	"userAdmin:userAdmin123456@$cluster-rs0.$namespace"
echo -n "Verifying user creation..."
until_with_timeout 10 check_user

desc "Testing logical backup with an unhealthy container"
type="logical"
write_data "This is some data for backup if unhealthy"
wait_sts_to_become_not_ready
wait_for_cluster_state "$cluster" "initializing|error"

backup_name_minio="backup-minio-$type"
run_backup "minio" "$backup_name_minio" "$type"
#wait_backup $backup_name_minio running #disabling this check temporarily as backup can be very fast in some platforms
verify_sts_not_ready
wait_for_cluster_state "$cluster" "initializing|error"

desc "Verifying $backup_name_minio and update cluster back to ready state"
wait_backup "$backup_name_minio" "ready"
verify_sts_not_ready
wait_for_cluster_state "$cluster" "initializing|error"
rollback_invalid_image
wait_for_cluster_state "$cluster" "ready"

desc "Delete data and run restore of $backup_name_minio"
delete_data "This is some data for backup if unhealthy"
run_restore "$backup_name_minio"
wait_restore "$backup_name_minio" "$cluster"
wait_for_cluster_state "$cluster" "ready"

desc "Verify data is back to the cluster"
simple_data_check "$cluster" 3 0 "-rs0"

destroy $namespace
desc 'test passed'
